/*******************************************************************************
 * MIT License
 *
 * Copyright (c) 2024 Answer Wong
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 ******************************************************************************/


#include "T3DCompileCommandTool.h"


namespace Tiny3D
{
    //--------------------------------------------------------------------------

    CompileCommandTool::CompileCommandTool()
    {

    }

    //--------------------------------------------------------------------------

    bool CompileCommandTool::execute(int argc, char *argv[])
    {
        bool ret = true;

        do
        {
            // 解析参数
            ret = parseCommand(argc, argv, mOptions);
            if (!ret)
            {
                break;
            }

            // 从 Compile_Commands.json 文件读取编译参数
            String flags;
            ret = readCompileCommands(flags);
            if (!ret)
            {
                break;
            }

            // 解析编译参数，解出头文件路径和宏定义
            StringList includePathes, macroDefinitions;
            ret = parseFlags(flags, includePathes, macroDefinitions);
            if (!ret)
            {
                break;
            }

            // 把头文件路径和宏定义写到 ReflectionSettings.json 文件
            ret = writeReflectionSettings(includePathes, macroDefinitions);
            if (!ret)
            {
                break;
            }
        } while (false);
        
        return ret;
    }

    //--------------------------------------------------------------------------

    bool CompileCommandTool::parseCommand(int argc, char *argv[], CCTOptions &options)
    {
        printCommand(argc, argv);

        bool ret = false;
        
        if (argc == 2)
        {
            const char *arg = argv[1];
            if (arg[0] == '-' && arg[1] == '?')
            {
                // 显示帮助
                printHelp();
                ret = true;
            }
        }
        else if (argc == 3)
        {
            // Compile_Commands.json 文件路径
            options.projPath = argv[1];
            // generated directory
            options.generatedPath = argv[2];
            ret = true;
        }
        else
        {
            // 参数错误
            printHelp();
        }

        return ret;
    }

    //--------------------------------------------------------------------------

    void CompileCommandTool::printCommand(int argc, char *argv[]) const
    {
        int i = 0;

        for (i = 1; i < argc; ++i)
        {
            if (i > 1)
                printf(" ");
            printf(argv[i]);
        }

        printf("\n");
    }

    //--------------------------------------------------------------------------

    void CompileCommandTool::printHelp() const
    {
        printf("Usage: cct <project directory> <generated directory>\n");
        printf("Arguments: \n");
        printf("\t-?                    : Display the help information.\n");
        printf("\tproject directory     : The directory including compile commands file (Compile_Commands.json) file.\n");
        printf("\tgenerated directory   : The directory including the source files generated by ReflectionPreprocessor.exe.\n");
    }
    
    //--------------------------------------------------------------------------

    bool CompileCommandTool::readCompileCommands(String &flags)
    {
        bool ret = false;

        do
        {
            const String &path = mOptions.projPath;
            String name = path + "/Compile_Commands.json";
            std::fstream ifs(name);
            rapidjson::IStreamWrapper isw(ifs); 
            rapidjson::Document d;
            ret = !d.ParseStream(isw).HasParseError();
            if (!ret)
            {
                // error
                printf("Error : Parse json [%s(offset %u)] failed ! \n", rapidjson::GetParseError_En(d.GetParseError()), (unsigned)d.GetErrorOffset());
                break;
            }

            if (!d.IsArray() || d.Empty())
            {
                // error
                printf("Error : Invalid json format ! The json must an array.\n");
                break;
            }

            const auto &obj = d[0];
            auto itr = obj.FindMember("command");
            if (itr == obj.MemberEnd())
            {
                // error
                printf("Invalid : json format ! The 'command' key did not found !\n");
                break;
            }

            flags = itr->value.GetString();
        } while (false);
        
        return ret;
    }

    //--------------------------------------------------------------------------

    bool CompileCommandTool::parseFlags(const String &flags, StringList &includePathes, StringList &macroDefinitions)
    {
        const std::function<void(const String&, const String&, StringList&)> extract = [](const String &origin, const String &prefix, StringList &result)
        {
            String::size_type pos = origin.find(prefix);
            while (pos != String::npos)
            {
                String::size_type start = pos + 2;
                String::size_type end = origin.find(' ', start);
                if (end == String::npos)
                {
                    end = origin.length();
                }
                String::size_type count = end - start;
                String str = origin.substr(start, count);
                result.push_back(str);
                pos = origin.find(prefix, end+1);    
            }
        };

        extract(flags, "-I", includePathes);
        extract(flags, "-D", macroDefinitions);
        
        return true;
    }

    //--------------------------------------------------------------------------

    bool CompileCommandTool::writeReflectionSettings(const StringList &includePathes, const StringList &macroDefinitions)
    {
        bool ret = true;

        String path = mOptions.projPath + "/ReflectionSettings.json";
        std::ofstream ofs(path);
        rapidjson::OStreamWrapper osw(ofs);
        
        rapidjson::PrettyWriter<rapidjson::OStreamWrapper> writer(osw);
        writer.StartObject();
        
        {
            // Include Path
            writer.Key("IncludePath");
            writer.StartArray();
            for (const auto &str : includePathes)
            {
                writer.String(str);
            }
            writer.EndArray();    
        }

        {
            // Macro Definitions
            writer.Key("MacroDefinition");
            writer.StartArray();
            for (const auto &str : macroDefinitions)
            {
                writer.String(str);
            }
            writer.EndArray();
        }

        {
            // Other Flags
            writer.Key("OtherFlags");
            writer.StartArray();
            writer.String("-x");
            writer.String("c++");
            writer.String("-std=c++17");
            writer.String("-fsyntax-only");
            writer.EndArray();
        }

        {
            // Generate Path
            writer.Key("GeneratedPath");
            writer.String(mOptions.generatedPath);
        }
        
        writer.EndObject();
        
        return ret;
    }

    //--------------------------------------------------------------------------

}

