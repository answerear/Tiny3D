/*******************************************************************************
 * MIT License
 *
 * Copyright (c) 2024 Answer Wong
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 ******************************************************************************/


#include <Tiny3D.h>


#if defined (T3D_OS_WINDOWS)

const char *SAMPLE_VERTEX_SHADER =
    "cbuffer type_Tiny3DPerDraw : register(b0)\n"
    "{\n"
    "    row_major float4x4 Tiny3DPerDraw_tiny3d_ObjectToWorld : packoffset(c0);\n"
    "    row_major float4x4 Tiny3DPerDraw_tiny3d_WorldToObject : packoffset(c4);\n"
    "};\n"
    "\n"
    "cbuffer type_Tiny3DPerFrame : register(b1)\n"
    "{\n"
    "    row_major float4x4 Tiny3DPerFrame_tiny3d_MatrixV : packoffset(c0);\n"
    "    row_major float4x4 Tiny3DPerFrame_tiny3d_MatrixP : packoffset(c4);\n"
    "    row_major float4x4 Tiny3DPerFrame_tiny3d_MatrixVP : packoffset(c8);\n"
    "};\n"
    "\n"
    "\n"
    "static float4 gl_Position;\n"
    "static float3 in_var_POSITION;\n"
    "static float2 in_var_TEXCOORD0;\n"
    "static float2 out_var_TEXCOORD0;\n"
    "\n"
    "struct SPIRV_Cross_Input\n"
    "{\n"
    "    float3 in_var_POSITION : POSITION;\n"
    "    float2 in_var_TEXCOORD0 : TEXCOORD0;\n"
    "};\n"
    "\n"
    "struct SPIRV_Cross_Output\n"
    "{\n"
    "    float2 out_var_TEXCOORD0 : TEXCOORD0;\n"
    "    float4 gl_Position : SV_Position;\n"
    "};\n"
    "\n"
    "void vert_main()\n"
    "{\n"
    "    gl_Position = mul(mul(Tiny3DPerFrame_tiny3d_MatrixVP, Tiny3DPerDraw_tiny3d_ObjectToWorld), float4(in_var_POSITION, 1.0f));\n"
    "    out_var_TEXCOORD0 = in_var_TEXCOORD0;\n"
    "}\n"
    "\n"
    "SPIRV_Cross_Output main(SPIRV_Cross_Input stage_input)\n"
    "{\n"
    "    in_var_POSITION = stage_input.in_var_POSITION;\n"
    "    in_var_TEXCOORD0 = stage_input.in_var_TEXCOORD0;\n"
    "    vert_main();\n"
    "    SPIRV_Cross_Output stage_output;\n"
    "    stage_output.gl_Position = gl_Position;\n"
    "    stage_output.out_var_TEXCOORD0 = out_var_TEXCOORD0;\n"
    "    return stage_output;\n"
    "}\n";

const char *SAMPLE_PIXEL_SHADER =
    "Texture2D<float4> texCube : register(t0);\n"
    "SamplerState samplertexCube : register(s1);\n"
    "\n"
    "static float2 in_var_TEXCOORD0;\n"
    "static float4 out_var_SV_Target;\n"
    "\n"
    "struct SPIRV_Cross_Input\n"
    "{\n"
    "    float2 in_var_TEXCOORD0 : TEXCOORD0;\n"
    "};\n"
    "\n"
    "struct SPIRV_Cross_Output\n"
    "{\n"
    "    float4 out_var_SV_Target : SV_Target0;\n"
    "};\n"
    "\n"
    "void frag_main()\n"
    "{\n"
    "    out_var_SV_Target = texCube.Sample(samplertexCube, in_var_TEXCOORD0);\n"
    "}\n"
    "\n"
    "SPIRV_Cross_Output main(SPIRV_Cross_Input stage_input)\n"
    "{\n"
    "    in_var_TEXCOORD0 = stage_input.in_var_TEXCOORD0;\n"
    "    frag_main();\n"
    "    SPIRV_Cross_Output stage_output;\n"
    "    stage_output.out_var_SV_Target = out_var_SV_Target;\n"
    "    return stage_output;\n"
    "}\n";

const char *SAMPLE_DIRECTIONAL_LIT_VERTEX_SHADER =
    "cbuffer type_Tiny3DPerDraw : register(b0)\n"
    "{\n"
    "    row_major float4x4 Tiny3DPerDraw_tiny3d_ObjectToWorld : packoffset(c0);\n"
    "    row_major float4x4 Tiny3DPerDraw_tiny3d_WorldToObject : packoffset(c4);\n"
    "};\n"
    "\n"
    "cbuffer type_Tiny3DPerFrame : register(b1)\n"
    "{\n"
    "    row_major float4x4 Tiny3DPerFrame_tiny3d_MatrixV : packoffset(c0);\n"
    "    row_major float4x4 Tiny3DPerFrame_tiny3d_MatrixP : packoffset(c4);\n"
    "    row_major float4x4 Tiny3DPerFrame_tiny3d_MatrixVP : packoffset(c8);\n"
    "};\n"
    "\n"
    "\n"
    "static float4 gl_Position;\n"
    "static float3 in_var_POSITION;\n"
    "static float3 in_var_NORMAL;\n"
    "static float2 in_var_TEXCOORD0;\n"
    "static float3 out_var_COLOR0;\n"
    "static float2 out_var_TEXCOORD0;\n"
    "\n"
    "struct SPIRV_Cross_Input\n"
    "{\n"
    "    float3 in_var_POSITION : POSITION;\n"
    "    float3 in_var_NORMAL : NORMAL;\n"
    "    float2 in_var_TEXCOORD0 : TEXCOORD0;\n"
    "};\n"
    "\n"
    "struct SPIRV_Cross_Output\n"
    "{\n"
    "    float3 out_var_COLOR0 : COLOR0;\n"
    "    float2 out_var_TEXCOORD0 : TEXCOORD0;\n"
    "    float4 gl_Position : SV_Position;\n"
    "};\n"
    "\n"
    "void vert_main()\n"
    "{\n"
    "    gl_Position = mul(mul(Tiny3DPerFrame_tiny3d_MatrixVP, Tiny3DPerDraw_tiny3d_ObjectToWorld), float4(in_var_POSITION, 1.0f));\n"
    "    out_var_COLOR0 = normalize(mul(float3x3(Tiny3DPerDraw_tiny3d_ObjectToWorld[0].xyz, Tiny3DPerDraw_tiny3d_ObjectToWorld[1].xyz, Tiny3DPerDraw_tiny3d_ObjectToWorld[2].xyz), in_var_NORMAL));\n"
    "    out_var_TEXCOORD0 = in_var_TEXCOORD0;\n"
    "}\n"
    "\n"
    "SPIRV_Cross_Output main(SPIRV_Cross_Input stage_input)\n"
    "{\n"
    "    in_var_POSITION = stage_input.in_var_POSITION;\n"
    "    in_var_NORMAL = stage_input.in_var_NORMAL;\n"
    "    in_var_TEXCOORD0 = stage_input.in_var_TEXCOORD0;\n"
    "    vert_main();\n"
    "    SPIRV_Cross_Output stage_output;\n"
    "    stage_output.gl_Position = gl_Position;\n"
    "    stage_output.out_var_COLOR0 = out_var_COLOR0;\n"
    "    stage_output.out_var_TEXCOORD0 = out_var_TEXCOORD0;\n"
    "    return stage_output;\n"
    "}\n"
    "\n";

const char *SAMPLE_DIRECTIONAL_LIT_PIXEL_SHADER =
    "cbuffer type_Globals : register(b2)\n"
    "{\n"
    "    float4 _Globals_tiny3d_CameraWorldPos : packoffset(c0);\n"
    "    float4 _Globals_tiny3d_AmbientLight : packoffset(c1);\n"
    "    float4 _Globals_tiny3d_LightDir : packoffset(c2);\n"
    "    float4 _Globals_tiny3d_LightDiffuseColor : packoffset(c3);\n"
    "    float4 _Globals_tiny3d_LightSpecularColor : packoffset(c4);\n"
    "    float4 _Globals_tiny3d_LightParams : packoffset(c5);\n"
    "};\n"
    "\n"
    "Texture2D<float4> texCube : register(t0);\n"
    "SamplerState samplertexCube : register(s1);\n"
    "\n"
    "static float4 gl_FragCoord;\n"
    "static float3 in_var_COLOR0;\n"
    "static float2 in_var_TEXCOORD0;\n"
    "static float4 out_var_SV_Target;\n"
    "\n"
    "struct SPIRV_Cross_Input\n"
    "{\n"
    "    float3 in_var_COLOR0 : COLOR0;\n"
    "    float2 in_var_TEXCOORD0 : TEXCOORD0;\n"
    "    float4 gl_FragCoord : SV_Position;\n"
    "};\n"
    "\n"
    "struct SPIRV_Cross_Output\n"
    "{\n"
    "    float4 out_var_SV_Target : SV_Target0;\n"
    "};\n"
    "\n"
    "void frag_main()\n"
    "{\n"
    "    float3 _52 = normalize(-_Globals_tiny3d_LightDir.xyz);\n"
    "    out_var_SV_Target = float4(((_Globals_tiny3d_AmbientLight.xyz * _Globals_tiny3d_AmbientLight.w) + ((_Globals_tiny3d_LightDiffuseColor.xyz * max(0.0f, dot(in_var_COLOR0, _52))) * _Globals_tiny3d_LightParams.x)) + (_Globals_tiny3d_LightSpecularColor.xyz * (_Globals_tiny3d_LightParams.y * pow(max(dot(normalize(_Globals_tiny3d_CameraWorldPos.xyz - gl_FragCoord.xyz), reflect(-_52, in_var_COLOR0)), 0.0f), _Globals_tiny3d_LightParams.z))), 1.0f) * texCube.Sample(samplertexCube, in_var_TEXCOORD0);\n"
    "}\n"
    "\n"
    "SPIRV_Cross_Output main(SPIRV_Cross_Input stage_input)\n"
    "{\n"
    "    gl_FragCoord = stage_input.gl_FragCoord;\n"
    "    in_var_COLOR0 = stage_input.in_var_COLOR0;\n"
    "    in_var_TEXCOORD0 = stage_input.in_var_TEXCOORD0;\n"
    "    frag_main();\n"
    "    SPIRV_Cross_Output stage_output;\n"
    "    stage_output.out_var_SV_Target = out_var_SV_Target;\n"
    "    return stage_output;\n"
    "}\n"
    "\n";

const char *SAMPLE_POINT_LIT_VERTEX_SHADER =
    "struct VertexInput\n"
    "{\n"
    "    float3 position;\n"
    "    float3 normal;\n"
    "    float2 uv;\n"
    "};\n"
    "\n"
    "struct VertexOutput\n"
    "{\n"
    "    float4 position;\n"
    "    float3 worldNormal;\n"
    "    float3 worldPos;\n"
    "    float2 uv;\n"
    "};\n"
    "\n"
    "cbuffer type_Tiny3DPerDraw : register(b0)\n"
    "{\n"
    "    row_major float4x4 Tiny3DPerDraw_tiny3d_ObjectToWorld : packoffset(c0);\n"
    "    row_major float4x4 Tiny3DPerDraw_tiny3d_WorldToObject : packoffset(c4);\n"
    "};\n"
    "\n"
    "cbuffer type_Tiny3DPerFrame : register(b1)\n"
    "{\n"
    "    row_major float4x4 Tiny3DPerFrame_tiny3d_MatrixV : packoffset(c0);\n"
    "    row_major float4x4 Tiny3DPerFrame_tiny3d_MatrixP : packoffset(c4);\n"
    "    row_major float4x4 Tiny3DPerFrame_tiny3d_MatrixVP : packoffset(c8);\n"
    "};\n"
    "\n"
    "\n"
    "static float4 gl_Position;\n"
    "static float3 in_var_POSITION;\n"
    "static float3 in_var_NORMAL;\n"
    "static float2 in_var_TEXCOORD0;\n"
    "static float3 out_var_COLOR0;\n"
    "static float3 out_var_COLOR1;\n"
    "static float2 out_var_TEXCOORD0;\n"
    "\n"
    "struct SPIRV_Cross_Input\n"
    "{\n"
    "    float3 in_var_POSITION : POSITION;\n"
    "    float3 in_var_NORMAL : NORMAL;\n"
    "    float2 in_var_TEXCOORD0 : TEXCOORD0;\n"
    "};\n"
    "\n"
    "struct SPIRV_Cross_Output\n"
    "{\n"
    "    float3 out_var_COLOR0 : COLOR0;\n"
    "    float3 out_var_COLOR1 : COLOR1;\n"
    "    float2 out_var_TEXCOORD0 : TEXCOORD0;\n"
    "    float4 gl_Position : SV_Position;\n"
    "};\n"
    "\n"
    "static float4x4 tiny3d_MatrixMVP;\n"
    "static float4x4 tiny3d_MatrixMV;\n"
    "\n"
    "VertexOutput src_vert(VertexInput _input)\n"
    "{\n"
    "    VertexOutput _output;\n"
    "    _output.position = mul(tiny3d_MatrixMVP, float4(_input.position, 1.0f));\n"
    "    _output.worldNormal = normalize(mul(float3x3(Tiny3DPerDraw_tiny3d_ObjectToWorld[0].xyz, Tiny3DPerDraw_tiny3d_ObjectToWorld[1].xyz, Tiny3DPerDraw_tiny3d_ObjectToWorld[2].xyz), _input.normal));\n"
    "    _output.worldPos = mul(Tiny3DPerDraw_tiny3d_ObjectToWorld, float4(_input.position, 1.0f)).xyz;\n"
    "    _output.uv = _input.uv;\n"
    "    return _output;\n"
    "}\n"
    "\n"
    "void vert_main()\n"
    "{\n"
    "    tiny3d_MatrixMVP = mul(Tiny3DPerFrame_tiny3d_MatrixVP, Tiny3DPerDraw_tiny3d_ObjectToWorld);\n"
    "    tiny3d_MatrixMV = mul(Tiny3DPerFrame_tiny3d_MatrixV, Tiny3DPerDraw_tiny3d_ObjectToWorld);\n"
    "    VertexInput _55 = { in_var_POSITION, in_var_NORMAL, in_var_TEXCOORD0 };\n"
    "    VertexInput param_var_input = _55;\n"
    "    VertexOutput _57 = src_vert(param_var_input);\n"
    "    gl_Position = _57.position;\n"
    "    out_var_COLOR0 = _57.worldNormal;\n"
    "    out_var_COLOR1 = _57.worldPos;\n"
    "    out_var_TEXCOORD0 = _57.uv;\n"
    "}\n"
    "\n"
    "SPIRV_Cross_Output main(SPIRV_Cross_Input stage_input)\n"
    "{\n"
    "    in_var_POSITION = stage_input.in_var_POSITION;\n"
    "    in_var_NORMAL = stage_input.in_var_NORMAL;\n"
    "    in_var_TEXCOORD0 = stage_input.in_var_TEXCOORD0;\n"
    "    vert_main();\n"
    "    SPIRV_Cross_Output stage_output;\n"
    "    stage_output.gl_Position = gl_Position;\n"
    "    stage_output.out_var_COLOR0 = out_var_COLOR0;\n"
    "    stage_output.out_var_COLOR1 = out_var_COLOR1;\n"
    "    stage_output.out_var_TEXCOORD0 = out_var_TEXCOORD0;\n"
    "    return stage_output;\n"
    "}\n"
    "\n";

const char *SAMPLE_POINT_LIT_PIXEL_SHADER =
    "struct PS_INPUT\n"
    "{\n"
    "    float3 worldNormal;\n"
    "    float3 worldPos;\n"
    "    float2 uv;\n"
    "};\n"
    "\n"
    "cbuffer type_Globals : register(b2)\n"
    "{\n"
    "    float4 _Globals_tiny3d_CameraWorldPos : packoffset(c0);\n"
    "    float4 _Globals_tiny3d_AmbientLight : packoffset(c1);\n"
    "    float4 _Globals_tiny3d_LightPos : packoffset(c2);\n"
    "    float4 _Globals_tiny3d_LightDiffuseColor : packoffset(c3);\n"
    "    float4 _Globals_tiny3d_LightSpecularColor : packoffset(c4);\n"
    "    float4 _Globals_tiny3d_LightParams[2] : packoffset(c5);\n"
    "};\n"
    "\n"
    "Texture2D<float4> texCube : register(t0);\n"
    "SamplerState samplertexCube : register(s1);\n"
    "\n"
    "static float3 in_var_COLOR0;\n"
    "static float3 in_var_COLOR1;\n"
    "static float2 in_var_TEXCOORD0;\n"
    "static float4 out_var_SV_Target;\n"
    "\n"
    "struct SPIRV_Cross_Input\n"
    "{\n"
    "    float3 in_var_COLOR0 : COLOR0;\n"
    "    float3 in_var_COLOR1 : COLOR1;\n"
    "    float2 in_var_TEXCOORD0 : TEXCOORD0;\n"
    "};\n"
    "\n"
    "struct SPIRV_Cross_Output\n"
    "{\n"
    "    float4 out_var_SV_Target : SV_Target0;\n"
    "};\n"
    "\n"
    "float4 src_frag(PS_INPUT _input)\n"
    "{\n"
    "    float3 ambient = _Globals_tiny3d_AmbientLight.xyz * _Globals_tiny3d_AmbientLight.w;\n"
    "    float3 lightDir = normalize(_Globals_tiny3d_LightPos.xyz - _input.worldPos);\n"
    "    float dist = length(_Globals_tiny3d_LightPos.xyz - _input.worldPos);\n"
    "    float constant = _Globals_tiny3d_LightParams[1].x;\n"
    "    float lin = _Globals_tiny3d_LightParams[1].y;\n"
    "    float quadratic = _Globals_tiny3d_LightParams[1].z;\n"
    "    float attenuation = 1.0f / ((constant + (lin * dist)) + ((quadratic * dist) * dist));\n"
    "    float diffuseIntensity = _Globals_tiny3d_LightParams[0].x;\n"
    "    float3 diffuse = ((_Globals_tiny3d_LightDiffuseColor.xyz * max(0.0f, dot(_input.worldNormal, lightDir))) * diffuseIntensity) * attenuation;\n"
    "    float specularIntensity = _Globals_tiny3d_LightParams[0].y;\n"
    "    float shininess = _Globals_tiny3d_LightParams[0].z;\n"
    "    float3 viewDir = normalize(_Globals_tiny3d_CameraWorldPos.xyz - _input.worldPos);\n"
    "    float3 reflectDir = reflect(-lightDir, _input.worldNormal);\n"
    "    float gloss = pow(max(dot(viewDir, reflectDir), 0.0f), shininess);\n"
    "    float3 specular = (_Globals_tiny3d_LightSpecularColor.xyz * (specularIntensity * gloss)) * attenuation;\n"
    "    float4 color = texCube.Sample(samplertexCube, _input.uv);\n"
    "    color = float4((ambient + diffuse) + specular, 1.0f) * color;\n"
    "    return color;\n"
    "}\n"
    "\n"
    "void frag_main()\n"
    "{\n"
    "    PS_INPUT _44 = { in_var_COLOR0, in_var_COLOR1, in_var_TEXCOORD0 };\n"
    "    PS_INPUT param_var_input = _44;\n"
    "    out_var_SV_Target = src_frag(param_var_input);\n"
    "}\n"
    "\n"
    "SPIRV_Cross_Output main(SPIRV_Cross_Input stage_input)\n"
    "{\n"
    "    in_var_COLOR0 = stage_input.in_var_COLOR0;\n"
    "    in_var_COLOR1 = stage_input.in_var_COLOR1;\n"
    "    in_var_TEXCOORD0 = stage_input.in_var_TEXCOORD0;\n"
    "    frag_main();\n"
    "    SPIRV_Cross_Output stage_output;\n"
    "    stage_output.out_var_SV_Target = out_var_SV_Target;\n"
    "    return stage_output;\n"
    "}\n"
    "\n";

#elif defined (T3D_OS_OSX)
#elif defined (T3D_OS_IOS)
#elif defined (T3D_OS_ANDROID)
#elif defined (T3D_OS_LINUX)
#endif
