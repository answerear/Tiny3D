#pragma fragment frag
#pragma target 4.0

#define CONCATENATE(a, b) a##b
#define TEX2D(name) Texture2D name; SamplerState CONCATENATE(sampler, name);
#define TEX2D_R(name, r) Texture2D name : register(CONCATENATE(t, r)); SamplerState CONCATENATE(sampler, name) : register(CONCATENATE(s, r));
#define SAMPLE(tex, uv) tex.Sample(CONCATENATE(sampler, tex), uv);


TEX2D(texCube);

#define T3D_MAX_POINT_LIGHTS	4	// 点光源支持的数量
#define T3D_MAX_SPOT_LIGHTS		4	// 聚光灯支持的数量


cbuffer tiny3d_LightParams
{
	// 环境光
	float4 tiny3d_AmbientLight;	// rgb - 环境光颜色, a - 强度

	// 平行光，只允许一个
	float4 tiny3d_DirLightColor;	// rgb - 颜色, a - diffuse 强度
	float4 tiny3d_DirLightDir;		// xyz - 方向, w - specular 强度

	// 点光源
	float4 tiny3d_PointLightColor[T3D_MAX_POINT_LIGHTS];	// rgb - 颜色, a - diffuse 强度
	float4 tiny3d_PointLightPos[T3D_MAX_POINT_LIGHTS];		// xyz - 位置, w - specular 强度
	float4 tiny3d_PointLightAttenuation[T3D_MAX_POINT_LIGHTS];	// x - 衰减常量项, y - 衰减一次项, z - 衰减二次项, w - padding

	// 聚光灯
	float4 tiny3d_SpotLightColor[T3D_MAX_SPOT_LIGHTS];			// rgb - 颜色, a - diffuse 强度
	float4 tiny3d_SpotLightPos[T3D_MAX_SPOT_LIGHTS];			// xyz - 位置, w - specular 强度
	float4 tiny3d_SpotLightDir[T3D_MAX_SPOT_LIGHTS];			// xyz - 方向, w - cutoff
	float4 tiny3d_SpotLightAttenuation[T3D_MAX_SPOT_LIGHTS];	// x - 衰减常量项, y - 衰减一次项, z - 衰减二次项, w - outer cutoff
}

cbuffer tiny3d_CameraParams
{
	float4 tiny3d_CameraWorldPos;	// 相机世界位置
}

cbuffer tiny3d_ObjectParams
{
	float4 tiny3d_ObjectSmoothness;	// x - 物体光滑度, yzw - padding
}

struct PS_INPUT
{
	float3 worldNormal : NORMAL;
	float3 worldPos : COLOR0;
    float2 uv : TEXCOORD0;
};

// 计算衰减值
float calcLightAttenuation(float3 lightPos, float3 pos, float attenuationConstant, float attenuationLinear, float attenuationQuadratic)
{
	float distance = length(lightPos - pos);
	float attenuation = 1.0 / (attenuationConstant + attenuationLinear * distance + attenuationQuadratic * distance * distance);
	return attenuation;
}

// 计算漫反射
float calcuateDiffuse(float3 normal, float3 lightDir)
{
	return max(0, dot(normal, lightDir));
}

// 计算镜面反射
float calculateSpecular(float3 viewDir, float3 normal, float3 lightDir, float smoothness)
{
	float shininess = smoothness * 128.0;
	float3 reflectDir = reflect(-lightDir, normal);
	return pow(max(dot(viewDir, reflectDir), 0.0), shininess);
}

// 计算方向光
float3 calcDirectionalLight(float3 normal, float3 viewDir, float3 albedo, float3 lightDir, float3 lightColor, float diffuseIntensity, float specularIntensity, float smoothness)
{
	// 漫反射系数
	float diffuse = calcuateDiffuse(normal, lightDir);

	// 镜面反射系数
	float specular = calculateSpecular(viewDir, normal, lightDir, smoothness);

	// 最终颜色
	return (diffuse * diffuseIntensity + specular * specularIntensity) * lightColor * albedo;
}

// 计算点光源
float3 calcPointLight(float3 pos, float3 normal, float3 viewDir, float3 albedo, float3 lightPos, float3 lightColor, float diffuseIntensity, float specularIntensity, float3 attenuation, float smoothness)
{
	// 计算衰减值
	float att = calcLightAttenuation(lightPos, pos, attenuation.x, attenuation.y, attenuation.z);

	// 计算光源方向
	float3 lightDir = normalize(lightPos - pos);

	// 漫反射系数
	float diffuse = calcuateDiffuse(normal, lightDir);

	// 镜面反射系数
	float specular = calculateSpecular(viewDir, normal, lightDir, smoothness);

	// 最终颜色
	return (diffuse * diffuseIntensity + specular * specularIntensity) * lightColor * albedo * att;
}

// 计算聚光灯

float4 frag(PS_INPUT input) : SV_Target
{
	// 物体的光滑度
	float smoothness = tiny3d_ObjectSmoothness.x;

	// 计算环境光
	float3 ambient = tiny3d_AmbientLight.rgb * tiny3d_AmbientLight.a;

	// 计算观察方向的反方向，从表面指向相机
	float3 viewDir = normalize(tiny3d_CameraWorldPos.xyz - input.worldPos);

	// 物体表面纹理
	float4 albedo = SAMPLE(texCube, input.uv);

	// 计算方向光
	float3 color = float3(0, 0, 0);
	float diffuseIntensity = tiny3d_DirLightColor.a;
	float specularIntensity = tiny3d_DirLightDir.w;
	float3 lightDir = tiny3d_DirLightDir.xyz;
	float3 lightColor = tiny3d_DirLightColor.rgb;
	float3 dirColor = calcDirectionalLight(input.worldNormal, viewDir, albedo.rgb, lightDir, lightColor, diffuseIntensity, specularIntensity, smoothness);
	color += dirColor;

	// 计算点光源
	[unroll]
	for (int i = 0; i < T3D_MAX_POINT_LIGHTS; i++)
	{
		diffuseIntensity = tiny3d_PointLightColor[i].a;
		specularIntensity = tiny3d_PointLightPos[i].w;
		float3 lightPos = tiny3d_PointLightPos[i].xyz;
		lightColor = tiny3d_PointLightColor[i].rgb;
		float3 pointColor = calcPointLight(input.worldPos, input.worldNormal, viewDir, albedo.rgb, lightPos, lightColor, diffuseIntensity, specularIntensity, tiny3d_PointLightAttenuation[i].xyz, smoothness);
		color += pointColor;
	}

	// 计算聚光灯


	// 最后把环境光算上
	float4 finalColor = float4(ambient * albedo.rgb + color, 1.0f);
    
    return finalColor;
}